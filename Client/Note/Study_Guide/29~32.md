Win32API Collider 및 Event Manager 심화 학습 가이드
===

퀴즈
---

1. 콜라이더 객체가 복사될 때 기본 복사 생성자의 문제점은 무엇이며, 이를 해결하기 위해 어떤 작업을 해야 하는가? <br/>
2. 콜라이더에서 복사 생성자를 직접 구현할 때 오브젝트 포인터 멤버를 어떻게 처리해야 하며 그 이유는 무엇인가? <br/>
3. 콜라이더 클래스에서 대입 연산자를 명시적으로 삭제한 이유는 무엇인가? <br/>
4. 콜리전 매니저에서 두 충돌체 간의 충돌 정보를 저장하기 위해 8바이트 정수를 키 값으로 사용하는 이유는 무엇인가? <br/>
5. LARGE_INTEGER 타입이 유니온으로 정의된 이유는 무엇인가? <br/>
6. C++에서 구조체와 유니온의 메모리 할당 방식의 차이점은 무엇인가? <br/>
7. 콜리전 매니저에서 두 충돌체가 충돌했을 때와 충돌에서 벗어났을 때 각각 어떤 함수를 호출하여 오브젝트에 알리는가? <br/>
8. 콜리전 매니저에서 충돌 상태를 관리할 때 카운트 변수를 사용하는 이유는 무엇인가? <br/>
9. 오브젝트 풀링 대신 이벤트 매니저를 사용하여 오브젝트 생성 및 삭제를 지연 처리하는 이유는 무엇인가? <br/>
10. 이벤트 매니저에서 오브젝트 삭제를 바로 처리하지 않고 'Dead' 상태로 변경한 후 지연 처리하는 이유는 무엇인가? <br/>

퀴즈 정답
---

1. 기본 복사 생성자는 멤버 변수 값을 그대로 복사하므로, 복사된 콜라이더 객체도 원본과 동일한 ID를 가지게 됩니다. 이는 각 콜라이더가 고유한 ID를 가져야 한다는 설계 원칙에 위배되므로, 복사 생성자를 직접 구현하여 새로운 ID를 할당해야 합니다.<br/>
2. 콜라이더의 오브젝트 포인터는 해당 콜라이더를 소유하는 오브젝트를 가리키는데, 복사 시 원본 오브젝트를 그대로 가리키는 것은 논리적으로 맞지 않습니다. 복사된 콜라이더는 새로운 오브젝트에 소유될 가능성이 있으므로, 복사 생성 시 오브젝트 포인터를 널 포인터로 초기화하는 것이 적절합니다.<br/>
3. 기본 대입 연산자는 콜라이더 객체 간 대입 시 ID 값을 복사하므로 고유성 유지가 되지 않습니다. 콜라이더 객체 간의 대입 연산 자체가 논리적으로 불필요하며 실수로 발생할 가능성을 방지하기 위해 대입 연산자를 삭제합니다.<br/>
4. 두 충돌체의 고유한 ID를 조합하여 하나의 키 값을 생성함으로써, 충돌체 조합마다 유일한 키를 만들 수 있습니다. 이를 통해 맵 자료구조에서 이전 프레임의 충돌 정보를 효율적으로 저장하고 검색할 수 있습니다.<br/>
5. LARGE_INTEGER는 8바이트 정수형이지만, 하위 4바이트씩 나누어 접근하거나 구조체 형태로 접근해야 하는 경우가 있기 때문에 유니온으로 정의되어 다양한 방식으로 동일한 메모리 공간을 해석할 수 있도록 합니다.<br/>
6. 구조체는 멤버 변수들을 순차적으로 메모리에 할당하여 모든 멤버가 독립적인 공간을 가지는 반면, 유니온은 모든 멤버가 하나의 공통된 메모리 공간을 공유하며, 가장 큰 멤버의 크기만큼 메모리를 할당합니다.<br/>
7. 충돌이 시작될 때는 각 오브젝트의 콜라이더에 OnCollisionEnter 함수를 호출하고, 충돌이 지속되는 동안에는 OnCollision 함수를 호출하며, 충돌이 끝날 때는 OnCollisionExit 함수를 호출합니다.<br/>
8. 하나의 콜라이더가 여러 개의 다른 콜라이더와 동시에 충돌할 수 있는 상황을 처리하기 위함입니다. 충돌이 시작될 때 카운트를 증가시키고, 충돌이 끝날 때 감소시켜, 카운트가 0보다 크면 충돌 중인 것으로 판단합니다.<br/>
9. 프레임 간의 일관성을 유지하고 예기치 않은 오류를 방지하기 위함입니다. 오브젝트를 즉시 생성하거나 삭제하면 같은 프레임 내에서도 오브젝트 존재 여부가 달라져 논리적 오류나 메모리 접근 오류가 발생할 수 있습니다.<br/>
10. 삭제될 오브젝트를 참조하고 있는 다른 오브젝트들에게 해당 오브젝트가 곧 삭제될 것이라는 정보를 제공하고, 참조를 끊거나 필요한 처리를 할 수 있는 시간을 주기 위함입니다. 즉시 삭제하면 참조하고 있던 오브젝트에서 오류가 발생할 수 있습니다.<br/>

에세이 형식 질문
---

1. Win32API 환경에서 콜라이더 시스템을 설계할 때 고유한 ID 할당 및 관리가 왜 중요한지 설명하고, 제시된 강의 내용에서 ID를 관리하는 방식과 그 이유는 무엇인지 구체적으로 논하시오.<br/>
2. C++의 복사 생성자와 대입 연산자가 콜라이더 시스템의 설계에 미치는 영향을 분석하고, 강의에서 이를 방지하기 위해 적용한 방법과 그 효과를 설명하시오.<br/>
3. 충돌 감지 로직을 구현할 때 두 충돌체의 위치와 크기 정보를 활용하는 방식에 대해 상세히 설명하고, 제시된 코드에서 충돌 여부를 판단하는 알고리즘을 분석하시오.<br/>
4. 게임 오브젝트의 생성 및 삭제를 즉시 처리하는 방식과 이벤트 매니저를 활용하여 지연 처리하는 방식의 장단점을 비교 분석하고, 강의에서 지연 처리 방식을 선택한 이유와 그 구현 방식을 설명하시오.<br/>
5. 이벤트 매니저에서 오브젝트 삭제를 '데드' 상태로 변경한 후 지연 처리하는 메커니즘을 상세히 설명하고, 이 방식이 게임 시스템의 안정성과 유지보수성에 미치는 긍정적인 영향에 대해 논하시오.<br/>

용어 해설
---

1. ****콜라이더**** (Collider): 게임 오브젝트의 물리적 충돌을 감지하는 컴포넌트입니다. 위치, 크기 등의 정보를 가지고 다른 콜라이더와의 겹침 여부를 판단합니다.<br/>
2. ***복사 생성자*** (Copy Constructor): 같은 클래스의 다른 객체를 이용하여 새로운 객체를 초기화할 때 호출되는 생성자입니다.<br/>
3. ***기본 복사 생성자*** (Default Copy Constructor): 클래스에 명시적인 복사 생성자가 정의되어 있지 않을 경우 컴파일러가 자동으로 생성하는 복사 생성자입니다. 멤버 변수들을 얕은 복사합니다.<br/>
4. ***깊은 복사*** (Deep Copy): 객체의 모든 멤버를 복사할 뿐만 아니라, 동적으로 할당된 메모리까지 새로 할당하여 복사하는 방식입니다.<br/>
5. ***얕은 복사*** (Shallow Copy): 객체의 멤버 변수 값만 복사하며, 동적으로 할당된 메모리의 주소 값만 복사하는 방식입니다.<br/>
6. ***대입 연산자*** (Assignment Operator): 이미 생성된 두 객체 간에 한 객체의 값을 다른 객체에 할당하는 연산자입니다.<br/>
7. ***유니온*** (Union): 여러 멤버 변수가 하나의 메모리 공간을 공유하는 자료형입니다. 가장 큰 멤버의 크기만큼 메모리가 할당되며, 동시에 하나의 멤버만 유효한 값을 가질 수 있습니다.<br/>
8. ***구조체*** (Structure): 여러 종류의 데이터를 묶어서 하나의 자료형으로 정의하는 복합 자료형입니다. 멤버들은 메모리에 순차적으로 할당됩니다.<br/>
9. ***정적 멤버*** (Static Member): 클래스의 모든 객체가 공유하는 멤버 변수 또는 멤버 함수입니다. 클래스 이름으로 직접 접근할 수 있습니다.<br/>
10. ***오브젝트 포인터*** (Object Pointer): 객체의 메모리 주소를 저장하는 변수입니다.<br/>
11. ***널 포인터*** (Null Pointer): 어떤 유효한 메모리 주소도 가리키지 않는 포인터입니다.<br/>
12. ***콜리전 매니저*** (Collision Manager): 게임 내의 모든 콜라이더들의 충돌을 검사하고, 충돌 이벤트를 처리하는 클래스입니다.<br/>
13. ***맵*** (Map): 키(Key)와 값(Value)의 쌍으로 이루어진 데이터를 저장하는 연관 컨테이너입니다. 키를 이용하여 값을 빠르게 검색할 수 있습니다.<br/>
14. ***이벤트 매니저*** (Event Manager): 게임 내에서 발생하는 다양한 이벤트들을 관리하고 처리하는 클래스입니다. 이벤트 발생 시 즉시 처리하지 않고 지연 처리하여 프레임 간의 일관성을 유지하는 데 사용됩니다.<br/>
15. ***가상 함수*** (Virtual Function): 파생 클래스에서 재정의(override)될 수 있는 멤버 함수입니다. 다형성을 구현하는 데 사용됩니다.<br/>
16. ***다형성*** (Polymorphism): 하나의 인터페이스가 여러 타입의 객체를 다룰 수 있도록 하는 객체 지향 프로그래밍의 특징입니다.<br/>
17. ***지연 처리*** (Deferred Processing): 특정 작업을 즉시 수행하지 않고, 일정 시점까지 보류했다가 일괄적으로 처리하는 방식입니다.<br/>
18. ***프렌드 클래스*** (Friend Class): 자신의 private 및 protected 멤버에 접근할 수 있도록 허용하는 다른 클래스입니다.<br/>
19. ***활성화/비활성화*** (Active/Inactive): 게임 오브젝트 또는 컴포넌트의 상태를 나타냅니다. 활성화된 오브젝트만 업데이트 및 렌더링 등의 처리가 이루어집니다.<br/>
20. ***데드 상태*** (Dead State): 오브젝트가 논리적으로 삭제된 상태를 의미하지만, 실제 메모리에서는 아직 존재하며 삭제 대기 중인 상태입니다.<br/>