Win32API 충돌 처리 학습 가이드
===

퀴즈
---

1. 게임에서 충돌 처리가 중요한 이유는 무엇이며, 충돌이 없다면 어떤 종류의 게임을 만들기가 어려워질까요?
2. 단순히 "충돌했다"는 정보만으로는 게임 개발 시 어떤 문제점이 발생할 수 있으며, 이를 해결하기 위해 어떤 종류의 충돌 이벤트 구분이 필요한가요?
3. 객체지향 설계 방식 중 상속의 단점은 무엇이며, 이러한 단점을 극복하기 위해 제시된 대안적인 구조는 무엇인가요?
4. 컴포넌트 기반 구조에서 충돌 처리 기능을 구현하기 위해 어떤 단계를 거치며, 각 오브젝트가 충돌체 컴포넌트를 어떻게 활용할 수 있나요?
5. 충돌체의 위치를 오브젝트의 위치와 별도로 관리하는 이유는 무엇이며, 이때 사용되는 '오프셋'의 개념을 설명해주세요.
6. 충돌체의 크기를 절대적인 값으로 설정하는 이유는 무엇이며, 디버깅 및 개발 편의를 위해 충돌체를 화면에 시각적으로 표현하는 방법은 무엇인가요?
7. 충돌 검사의 효율성을 높이기 위해 오브젝트를 그룹으로 나누어 관리하는 이유는 무엇이며, 그룹 간의 충돌 여부를 어떻게 설정하고 관리할 수 있나요?
8. 씬 매니저와 충돌 매니저의 업데이트 시점은 어떻게 연결되어 있으며, 충돌 검사는 게임 루프의 어느 시점에서 이루어지는 것이 적절한가요?
9. 충돌 매니저에서 그룹 간의 충돌 가능성을 효율적으로 관리하기 위해 어떤 자료 구조와 비트 연산 기법이 사용되며, 중복 검사를 피하기 위한 전략은 무엇인가요?
10. 충돌 발생 시점을 정확하게 파악하기 위해 충돌 매니저는 어떤 추가적인 정보를 관리해야 하며, 이를 위해 각 충돌체에 어떤 속성을 부여해야 할까요?

퀴즈 정답
---

1. 충돌은 게임 내 물체들 간의 상호작용을 가능하게 하는 핵심 요소이며, 충돌이 없다면 상호작용이나 물리적인 접촉이 중요한 액션 게임, 격투 게임, 시뮬레이션 게임 등을 만들기가 어렵습니다. 충돌은 게임의 재미와 현실감을 부여하는 데 필수적인 역할을 합니다.
2. 단순히 충돌 여부만으로는 지속적인 충돌 상황에서 매 프레임마다 동일한 액션이 반복되는 문제가 발생할 수 있으며, 이를 해결하기 위해 충돌 시작, 충돌 지속, 충돌 종료의 세 가지 이벤트 구분이 필요합니다. 이를 통해 개발자는 각 상황에 맞는 적절한 게임 로직을 구현할 수 있습니다.
3. 상속 기반 객체 설계는 초기 설계에는 용이하지만, 기획 변경이나 새로운 기능 추가 시 확장성이 떨어지는 단점이 있습니다. 특히 예상치 못한 예외 상황 발생 시 전체 구조를 변경해야 할 수 있습니다. 이를 극복하기 위한 대안으로 컴포넌트 기반 구조가 제시됩니다.
4. 충돌 처리 기능을 별도의 '충돌체' 컴포넌트 클래스로 정의하고, 충돌이 필요한 오브젝트는 이 컴포넌트를 멤버로 포함시킵니다. 오브젝트는 필요에 따라 충돌체를 생성하고 관리하며, 충돌체의 활성화/비활성화 여부를 통해 충돌 기능을 선택적으로 사용할 수 있습니다.
5. 충돌체의 위치를 오브젝트의 위치와 별도로 관리하는 이유는 더 유연한 충돌 영역 설정을 위해서입니다. 예를 들어 캐릭터의 머리 부분에만 충돌체를 배치하여 헤드샷 판정을 구현하거나, 오브젝트 중심이 아닌 특정 부위에 충돌 영역을 설정할 수 있습니다. 이때 오브젝트의 위치를 기준으로 상대적인 변위 값을 나타내는 '오프셋' 개념이 사용됩니다.
6. 현재 강의에서는 JPA 추가 시 오브젝트 스케일 변경이 없을 것이라는 가정하에 충돌체 크기를 직관적인 절대적인 값으로 설정합니다. 개발 중 충돌 영역을 시각적으로 확인하기 위해 디버깅 모드에서 충돌체의 외곽선을 특정 색상으로 화면에 렌더링하는 방법을 사용합니다.
7. 충돌 검사 시 모든 오브젝트 간의 일대일 비교는 연산량이 매우 많아지므로, 충돌 가능성이 있는 오브젝트들을 그룹으로 나누어 그룹 간에만 충돌 검사를 수행하여 효율성을 높입니다. 각 그룹은 고유한 ID를 가지며, 씬에서는 어떤 그룹과 어떤 그룹이 충돌할 것인지 미리 지정하여 관리합니다.
8. 씬 매니저는 게임 내 모든 씬의 업데이트를 관리하며, 각 씬의 오브젝트 업데이트가 완료된 후 충돌 매니저의 업데이트가 호출됩니다. 충돌 검사는 각 프레임의 오브젝트 상태가 갱신된 이후, 화면 렌더링 직전에 수행되어 변경된 상태를 기준으로 충돌 여부를 정확하게 판단합니다.
9. 충돌 매니저에서는 32개의 그룹 간의 충돌 가능성을 32개의 4바이트 정수 배열을 이용하여 비트 마스크 형태로 효율적으로 관리합니다. 각 정수의 각 비트는 특정 그룹과의 충돌 여부를 나타냅니다. 중복 검사를 피하기 위해 그룹 ID를 기준으로 항상 작은 값을 행, 큰 값을 열로 지정하여 비트 마스크를 설정하고 검사합니다.
10. 충돌 발생 시점을 정확하게 파악하기 위해 충돌 매니저는 각 충돌체 쌍의 이전 프레임 충돌 정보를 저장하고 있어야 합니다. 이를 위해 각 충돌체에 고유한 ID 값을 부여하고, 이 ID 쌍을 키로 사용하여 이전 충돌 상태를 관리하는 자료 구조(예: 맵)를 활용할 수 있습니다.

에세이 형식 질문
---

1. 게임 개발에서 충돌 처리의 중요성을 다양한 게임 장르의 예를 들어 설명하고, 효과적인 충돌 처리가 게임 플레이 경험에 미치는 영향을 분석하시오.
2. 상속 기반 설계와 컴포넌트 기반 설계의 개념을 비교 설명하고, 게임 오브젝트의 충돌 처리 시스템을 설계하는 관점에서 각 설계 방식의 장단점을 논하시오.
3. 효율적인 충돌 검사를 위한 그룹 관리 시스템의 필요성을 설명하고, 다양한 그룹 전략과 충돌 검사 최적화 기법을 제안하시오.
4. 게임 루프 내에서 충돌 검사의 적절한 시점을 결정하는 요인들을 분석하고, 프레임워크 레벨에서의 충돌 관리 시스템의 역할과 책임을 논하시오.
5. 충돌 이벤트의 종류(진입, 지속, 종료)를 정의하고, 각 이벤트에 따른 게임 로직 처리의 중요성을 설명하며, 이전 프레임 정보를 활용한 충돌 이벤트 감지 메커니즘을 설계하시오.

용어 사전
---

1. ***충돌*** (Collision): 게임 내 두 개 이상의 물체가 서로 물리적으로 겹치거나 접촉하는 현상.
2. ***충돌체*** (Collider): 오브젝트의 충돌 영역을 정의하는 컴포넌트 또는 객체. 실제 렌더링 되는 형태와 다를 수 있으며, 충돌 감지를 위한 경계 역할을 함.
3. ***바운딩 박스*** (Bounding Box): 오브젝트를 감싸는 가장 작은 직육면체 또는 사각형 영역. 기본적인 충돌 검사에 사용됨.
4. ***DT*** (Delta Time): 이전 프레임과 현재 프레임 사이의 시간 간격. 게임 내 애니메이션, 움직임, 물리 연산 등을 시간의 흐름에 따라 부드럽게 처리하는 데 사용됨.
5. ***이벤트*** (Event): 게임 내에서 발생하는 특정 사건이나 신호. 충돌 시작, 키 입력, 마우스 클릭 등이 이벤트에 해당함.
6. ***상속*** (Inheritance): 객체지향 프로그래밍의 특징 중 하나로, 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 사용하는 메커니즘. 코드 재사용성을 높이지만, 구조적 확장성이 제한될 수 있음.
7. ***컴포넌트 기반 구조*** (Component-Based Architecture): 객체를 독립적인 기능 단위인 컴포넌트들의 조합으로 구성하는 설계 방식. 유연성과 확장성이 높음.
8. ***오프셋*** (Offset): 기준 위치로부터 상대적인 거리 또는 변위 값. 충돌체의 위치를 오브젝트 위치를 기준으로 미세하게 조정하는 데 사용됨.
9. ***그룹*** (Group): 게임 내 오브젝트들을 특정 기준에 따라 묶어 놓은 집합. 충돌 검사의 효율성을 높이기 위해 사용됨.
10. ***레이어*** (Layer): 오브젝트들을 시각적인 깊이 또는 논리적인 우선순위에 따라 분류하는 방식. 렌더링 순서나 충돌 처리 대상 등을 결정하는 데 사용됨 (본 강의에서는 그룹과 유사한 개념으로 사용됨).
11. ***비트 연산*** (Bitwise Operation): 이진수 형태로 표현된 데이터의 각 비트를 조작하는 연산. 플래그 설정, 마스크 처리 등에 효율적으로 사용됨.
12. ***비트 마스크*** (Bitmask): 비트 단위의 정보를 저장하고 관리하는 데 사용되는 정수형 데이터. 각 비트가 특정 상태나 속성을 나타냄.
13. ***싱글톤*** (Singleton): 프로그램 실행 동안 단 하나의 인스턴스만 생성되도록 제한하는 디자인 패턴. 게임 매니저 클래스 등에 사용됨.
14. ***자료 구조*** (Data Structure): 데이터를 효율적으로 저장, 접근, 관리하기 위한 구조. 배열, 리스트, 맵 등이 있음.
15. ***탐색*** (Search): 자료 구조 내에서 특정 조건에 맞는 데이터를 찾아내는 과정.