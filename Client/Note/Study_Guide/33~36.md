Win32API 게임 개발 심화 학습 가이드
===

퀴즈
---

1. 오브젝트가 삭제될 때, 이벤트 매니저는 어떤 방식으로 실제 삭제를 지연 처리하는가?<br/>
2. 충돌 처리 과정에서 삭제 예정인 오브젝트와 충돌이 발생했을 경우, 충돌 매니저는 어떤 특별한 처리를 고려해야 하는가?<br/>
3. 씬 매니저에서 씬 전환 기능을 즉시 처리하지 않고 이벤트 등록 방식으로 처리하는 이유는 무엇인가?<br/>
4. 씬이 변경될 때, 이전 씬의 종료 시점과 새로운 씬의 시작 시점에 호출되는 가상 함수는 각각 무엇이며, 그 역할은 무엇인가?<br/>
5. 템플릿 함수 ClearContainer를 사용하는 주된 이유는 무엇이며, 이 함수는 벡터 내의 객체들을 어떻게 안전하게 정리하는가?<br/>
6. 오브젝트의 복사 생성자를 직접 구현해야 하는 주요 이유는 무엇이며, 기본 복사 생성자를 사용했을 때 발생할 수 있는 문제는 무엇인가?<br/>
7. 오브젝트 클래스에 순수 가상 함수 Clone을 추가한 이유는 무엇이며, 이 함수는 어떤 역할을 수행하는가?<br/>
8. 컴포넌트 기반 설계에서 애니메이터 컴포넌트를 오브젝트에 추가하는 이유는 무엇이며, 상속 대신 컴포넌트를 사용하는 이점은 무엇인가?<br/>
9. 애니메이터 컴포넌트가 관리해야 하는 주요 요소는 무엇이며, 애니메이션을 효율적으로 관리하기 위해 어떤 자료구조를 사용하는가?<br/>
10. 오브젝트가 소멸될 때, 애니메이터 컴포넌트와 그 안에 포함된 애니메이션들을 어떻게 정리해야 하는지 설명하시오.<br/>

퀴즈 정답
---

1. 오브젝트가 삭제 요청을 받으면, 이벤트 매니저는 해당 오브젝트를 즉시 삭제하는 대신 '데드' 상태로 표시하고 별도의 벡터에 보관한다. 실제 메모리 해제는 다음 프레임의 업데이트가 완료된 후 이벤트 매니저가 이 '데드' 벡터를 순회하며 처리한다.<br/>
2. 삭제 예정인 오브젝트와의 충돌이 발생하면, 충돌 매니저는 해당 충돌을 무효화하거나 충돌 해제된 것으로 처리해야 한다. 이는 이미 다음 프레임에 사라질 오브젝트와의 불필요한 충돌 반응을 방지하고, 관련 오브젝트들이 안정적으로 상태를 정리하도록 돕기 위함이다.<br/>
3. 씬 전환을 즉시 처리하면 현재 프레임의 업데이트, 파이널 업데이트, 렌더링 과정이 불완전하게 종료되거나 새로운 씬의 초기화가 제대로 이루어지지 않을 수 있다. 이벤트 등록 방식을 통해 씬 전환 시점을 다음 프레임의 적절한 시점으로 지연시켜 안정적인 씬 전환을 보장한다.<br/>
4. 씬에 진입할 때 호출되는 가상 함수는 Enter이며, 새로운 씬이 시작될 때 필요한 초기화 작업을 수행한다. 씬에서 빠져나갈 때 호출되는 가상 함수는 Exit이며, 현재 씬의 자원 해제 및 종료 작업을 수행한다.<br/>
5. ClearContainer 템플릿 함수는 벡터와 같은 컨테이너 내에 동적 할당된 객체들을 안전하게 삭제하고 컨테이너를 비우기 위해 사용된다. 이 함수는 벡터를 순회하며 각 요소가 가리키는 메모리를 해제하고, 최종적으로 벡터 자체의 내용을 모두 제거한다.<br/>
6. 오브젝트의 복사 생성자를 직접 구현해야 하는 주된 이유는 오브젝트가 보유한 컴포넌트 (예: 콜라이더)가 포인터 형태로 관리되기 때문이다. 기본 복사 생성자는 포인터의 주소값만 복사하므로, 복사된 오브젝트가 원본 오브젝트의 컴포넌트를 공유하여 예기치 않은 side effect를 발생시킬 수 있다.<br/>
7. 오브젝트 클래스에 순수 가상 함수 Clone을 추가한 이유는 각 파생 클래스가 자신의 복사본을 생성하는 방식을 정의하도록 강제하기 위함이다. 이 함수는 현재 오브젝트와 동일한 속성과 상태를 가진 새로운 오브젝트 인스턴스를 동적으로 생성하여 반환하는 역할을 한다.<br/>
8. 애니메이터 컴포넌트를 사용하는 이유는 오브젝트가 애니메이션 기능을 가질 수도 있고 가지지 않을 수도 있는 유연성을 제공하기 위함이다. 상속 대신 컴포넌트를 사용하면 필요한 기능만 오브젝트에 추가할 수 있어 코드의 재사용성을 높이고 클래스 계층 구조를 단순화할 수 있다.<br/>
9. 애니메이터 컴포넌트는 오브젝트의 애니메이션 상태 및 현재 재생 중인 애니메이션, 그리고 다양한 애니메이션 데이터들을 관리해야 한다. 애니메이션을 효율적으로 관리하기 위해 문자열 키를 사용하는 맵(Map) 자료구조를 활용하여 특정 이름의 애니메이션을 빠르게 찾고 재생할 수 있도록 한다.<br/>
10. 오브젝트가 소멸될 때, 해당 오브젝트가 보유한 애니메이터 컴포넌트도 함께 삭제해야 한다. 애니메이터의 소멸자에서는 자신이 관리하고 있는 모든 애니메이션 객체들을 순회하며 메모리에서 해제하여 메모리 누수를 방지해야 한다.<br/>

에세이 형식 질문
---

1. 제시된 강의 내용을 바탕으로, 게임 오브젝트의 생명 주기 (생성, 업데이트, 소멸) 전반에 걸쳐 이벤트 매니저가 어떤 역할을 수행하며, 이를 통해 얻을 수 있는 이점은 무엇인지 상세하게 설명하시오.<br/>
2. 충돌 처리 시스템의 설계 관점에서, 삭제 예정인 오브젝트와의 충돌을 효율적으로 처리하기 위한 전략들을 제시하고, 각 전략의 장단점을 논하시오.<br/>
3. 씬 관리 시스템의 설계에서 씬 전환 방식을 이벤트 기반으로 처리하는 것의 기술적인 이유와 이점을 설명하고, 다른 씬 전환 방식과 비교하여 논하시오.<br/>
4. 객체 복사 메커니즘의 중요성을 강조하고, 깊은 복사와 얕은 복사의 차이점을 명확히 설명하며, 게임 개발에서 깊은 복사가 필요한 구체적인 사례를 제시하시오.<br/>
5. 컴포넌트 기반 설계 방식이 게임 개발의 유연성과 확장성에 기여하는 바를 애니메이션 시스템 구축 사례를 중심으로 설명하고, 상속 기반 설계 방식과의 차이점을 비교 분석하시오.<br/>

용어 해설
---

1. ***이벤트 매니저*** (Event Manager): 게임 내에서 발생하는 다양한 이벤트 (오브젝트 생성/삭제, 충돌, 씬 전환 등)를 등록, 관리, 처리하는 시스템. 비동기적인 처리를 가능하게 하여 안정적인 게임 루프를 유지하는 데 기여한다.<br/>
2. ***콜리전*** (Collision): 게임 내의 두 개 이상의 오브젝트가 서로 물리적으로 접촉하거나 겹치는 현상. 충돌 감지 및 반응 처리는 게임 플레이의 핵심적인 요소이다.<br/>
3. ***씬*** (Scene): 게임의 독립적인 화면 또는 단계를 나타내는 개념. 각 씬은 고유한 오브젝트 구성, 배경, 게임 로직을 가질 수 있으며, 씬 매니저를 통해 관리되고 전환된다.<br/>
4. ***오브젝트*** (Object): 게임을 구성하는 모든 요소의 기본 단위 (플레이어, 몬스터, 배경 등). 속성 (위치, 크기, 상태 등)과 행동 (업데이트, 렌더링 등)을 포함한다.<br/>
5. ***컴포넌트*** (Component): 오브젝트에 특정 기능이나 속성을 추가하기 위해 사용되는 독립적인 모듈. 오브젝트는 여러 개의 컴포넌트를 가질 수 있으며, 컴포넌트 기반 설계는 코드의 재사용성과 유지보수성을 높인다.<br/>
6. ***상속*** (Inheritance): 객체 지향 프로그래밍의 특징 중 하나로, 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 사용할 수 있도록 하는 메커니즘. 코드의 재사용성을 높이지만, 클래스 계층 구조가 복잡해질 수 있다.<br/>
7. ***가상 함수*** (Virtual Function): 부모 클래스에서 선언되고 자식 클래스에서 재정의(오버라이딩)될 수 있는 함수. 런타임 시점에 실제 객체의 타입에 따라 호출될 함수가 결정되는 동적 바인딩을 지원한다.<br/>
8. ***템플릿*** (Template): C++에서 제공하는 제네릭 프로그래밍 기능으로, 함수나 클래스를 특정 타입에 종속되지 않게 정의하여 다양한 타입에 대해 재사용할 수 있도록 한다.<br/>
9. ***깊은 복사*** (Deep Copy): 객체를 복사할 때 객체의 값뿐만 아니라 객체가 참조하는 다른 객체까지 모두 새롭게 복사하는 방식. 원본 객체와 복사된 객체가 완전히 독립적인 상태를 유지한다.<br/>
10. ***얕은 복사*** (Shallow Copy): 객체를 복사할 때 객체의 값만 복사하고 객체가 참조하는 다른 객체는 주소값만 복사하는 방식. 원본 객체와 복사된 객체가 참조하는 객체를 공유하게 된다.<br/>
11. ***애니메이션*** (Animation): 여러 장의 이미지나 프레임을 순차적으로 빠르게 보여줌으로써 움직이는 듯한 시각적 효과를 만들어내는 기술. 게임 캐릭터나 배경의 움직임을 표현하는 데 필수적이다.<br/>
12. ***프레임*** (Frame): 애니메이션이나 게임 화면을 구성하는 정지된 이미지 한 장. 게임은 초당 여러 프레임을 표시하여 부드러운 움직임을 구현한다.<br/>
13. ***애니메이터*** (Animator): 오브젝트의 애니메이션 재생 및 관리를 담당하는 컴포넌트. 다양한 애니메이션 클립을 저장하고, 현재 재생 중인 애니메이션 상태를 관리하며, 필요한 애니메이션으로 전환하는 역할을 수행한다.<br/>