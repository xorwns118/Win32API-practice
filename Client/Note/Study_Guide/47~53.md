Win32API UI 스터디 가이드
===

퀴즈
---

1. 타일 최대 개수를 넘어선 마우스 클릭 위치 예외 처리를 어떻게 하였는가?
2. 마우스 좌표가 음수로 넘어갔을 때 정수 나눗셈의 문제점은 무엇이었는가?
3. Unsigned Int로 캐스팅했을 때 음수 좌표에 문제가 생기는 이유는 무엇인가?
4. UI 오브젝트를 다른 오브젝트들보다 렌더링 그룹 순서상 가장 나중에 배치하는 이유는 무엇인가?
5. 카메라 영향을 받지 않는 UI의 특징은 무엇인가?
6. UI에서 마우스 클릭 이벤트의 정의는 무엇인가?
7. UI 매니저가 필요한 이유는 무엇인가?
8. UI 계층 구조(부모-자식)로 설계했을 때의 이점 두 가지는 무엇인가?
9. 마우스 이벤트를 받을 타겟 UI를 찾을 때 가장 낮은 계층(가장 깊은 자식)의 UI가 우선순위가 높은 이유는 무엇인가?
10. UI 그룹 내에서 포커싱된 UI를 벡터의 맨 뒤로 옮기는 이유는 무엇인가?

퀴즈 정답
---
1. 컬럼 열이 최대 타일 개수를 넘어섰는지 확인하여 예외 처리하였다. 또한 마우스 좌표 자체가 음수가 아닌지로 왼쪽 경계 예외 처리를 추가하였다.
2. 음수 좌표를 타일 사이즈로 나눌 경우, 정수 나눗셈 결과가 0으로 나와서 음수 영역도 0번째 컬럼으로 인식하는 문제가 발생하였다.
3. Unsigned Int로 캐스팅하면 음수의 최상위 비트 1이 양의 정수에서는 매우 큰 숫자로 해석되어 좌표 계산에 문제가 생긴다.
4. UI가 캐릭터나 다른 오브젝트에 가려지지 않고 항상 최상단에 표시되도록 하기 위함이다.
5. 카메라의 스크롤이나 이동과 상관없이 항상 화면의 고정된 위치에 표시된다.
6. UI 영역 내에서 마우스 왼쪽 버튼이 눌렸다가 다시 UI 영역 내에서 떼졌을 때를 클릭으로 정의한다.
7. 모든 UI 오브젝트의 상태를 체크하고, 특정 이벤트 발생 시 해당 UI의 적절한 이벤트 함수를 호출하여 알림을 처리하기 위해서이다.
8. 업데이트 및 렌더링 순서를 계층적으로 관리하기 용이하며, 부모 UI 이동 시 자식 UI도 함께 이동하는 등 그룹 관리가 편리해진다.
9. 여러 UI가 겹쳐 있을 때 사용자는 가장 상위에 보이는 UI와 상호작용하려 하기 때문에, 가장 깊은 계층의 UI가 이벤트를 가져가는 것이 상식적이다.
10. 가장 나중에 렌더링되는 UI가 가장 위에 표시되도록 하여, 현재 포커싱된 UI가 다른 UI에 가려지지 않고 항상 최상단에 보이게 하기 위해서이다.

에세이 형식 질문
---

1. UI에서 마우스 이벤트 처리를 위해 L Button Down, L Button Up, Mouse On 등 다양한 이벤트 시점을 분할하여 관리하는 이유와 각 이벤트 시점의 의미를 설명하시오.
2. UI 클래스를 추상 클래스로 설계하고, 실제 사용할 UI (예: Panel UI, Button UI)를 상속받아 구현하는 방식의 장점을 객체 지향 설계 관점에서 설명하시오.
3. UI 그룹 내에서 마우스 이벤트를 받을 타겟 UI를 결정하기 위해 레벨 순회(Level Traversal) 방식을 사용하는 이유와 Queue 자료구조를 활용하여 레벨 순회를 구현하는 과정을 설명하시오.
4. Win32API 환경에서 UI 오브젝트의 복사 생성자를 깊은 복사로 구현해야 하는 이유와, 자식 UI를 가지는 부모 UI의 복사 생성자 구현 시 주의해야 할 점을 설명하시오.
5. UI 매니저가 부모 UI들 간의 포커싱 상태를 관리하는 방법과, 포커싱된 UI만 이벤트를 받아가도록 처리하는 방식, 그리고 포커싱이 변경되었을 때 렌더링 순서를 조정하는 과정을 설명하시오.

용어 사전
---

1. ***타일*** (Tile): 게임 맵 등을 구성하는 기본적인 사각형 단위.
2. ***컬럼*** (Column): 타일 맵의 세로 열.
3. ***행*** (Row): 타일 맵의 가로 행.
4. ***예외 처리*** (Exception Handling): 프로그램 실행 중 발생할 수 있는 예상치 못한 상황(오류)에 대해 미리 정의된 방식으로 처리하는 것.
5. ***UI*** (User Interface): 사용자가 프로그램 또는 시스템과 상호작용하기 위한 화면 구성 요소.
6. ***인게임 UI*** (In-Game UI): 게임 플레이 도중 화면에 표시되는 UI 요소 (예: HP 바, 미니맵, 아이템 창 등).
7. ***다이얼로그*** (Dialog): 사용자에게 정보를 표시하거나 사용자로부터 입력을 받기 위해 뜨는 작은 창.
8. ***오브젝트*** (Object): 게임이나 프로그램의 구성 요소로, 데이터(상태)와 함수(행동)를 가지는 독립적인 단위.
9. ***렌더링*** (Rendering): 프로그램 상의 데이터를 실제 화면에 그림으로 그리는 과정.
10. ***좌상단 좌표*** (Top-Left Coordinate): 객체의 위치를 나타낼 때 왼쪽 위 모서리의 좌표를 기준으로 하는 방식.
11. ***카메라 영향*** (Camera Influence): 오브젝트의 위치나 렌더링이 게임 카메라의 이동이나 시야각에 따라 달라지는 것. UI의 경우 카메라의 영향을 받지 않고 화면에 고정되는 경우가 많다.
12. ***추상 클래스*** (Abstract Class): 직접 객체를 생성할 수는 없지만, 다른 클래스들에게 공통적인 기능이나 구조를 제공하는 클래스. 종종 순수 가상 함수를 포함한다.
13. ***객체화*** (Instantiation): 클래스로부터 실제 메모리에 할당된 오브젝트를 생성하는 과정.
14. ***계층 구조*** (Hierarchical Structure): 부모-자식 관계처럼 상하 관계를 가지는 구조. UI에서는 부모 UI 안에 자식 UI가 포함되는 형태로 설계된다.
15. ***업데이트*** (Update): 게임 루프의 한 단계로, 매 프레임마다 오브젝트의 상태나 위치 등을 갱신하는 과정.
16. ***파이널 업데이트*** (Final Update): 업데이트 과정 이후 렌더링 전에 최종적으로 오브젝트의 상태를 확정하는 단계.
17. ***렌더링 순서*** (Rendering Order): 여러 오브젝트가 화면에 그려질 때 어떤 오브젝트를 먼저 그릴지 정하는 순서. 뒤에 그려지는 오브젝트가 앞에 그려진 오브젝트를 덮어쓴다.
18. ***벡터*** (Vector): 크기가 동적으로 변할 수 있는 동적 배열 컨테이너. C++의 std::vector.
19. ***오프셋 포지션*** (Offset Position): 부모 오브젝트의 위치를 기준으로 상대적인 위치.
20. ***최종 위치*** (Final Position): 모든 계산 (예: 부모 위치 + 오프셋, 카메라 영향 등)을 마친 최종적인 화면상의 위치.
21. ***이벤트 처리*** (Event Handling): 사용자 입력(클릭, 키 입력 등)이나 시스템 메시지와 같은 이벤트가 발생했을 때 사전에 정의된 동작을 수행하는 것.
22. ***이벤트 함수*** (Event Function): 특정 이벤트가 발생했을 때 호출되도록 설계된 함수.
23. ***가상 함수*** (Virtual Function): 부모 클래스에 선언되고 자식 클래스에서 오버라이딩(재정의)될 수 있는 함수. 런타임 시 실제 객체의 타입에 따라 호출되는 함수가 결정된다.
24. ***오버라이딩*** (Overriding): 자식 클래스에서 부모 클래스의 가상 함수를 재정의하는 것.
25. ***UI 매니저*** (UI Manager): 게임 내 모든 UI 오브젝트를 관리하고 이벤트 처리를 중재하는 역할을 하는 객체.
26. ***카메라 영향 유무*** (Camera Affection Status): UI가 카메라의 이동 및 스크롤에 영향을 받는지 여부를 나타내는 상태 변수.
27. ***패널 UI*** (Panel UI): 다른 UI 요소들을 담거나 그룹화하는 배경 역할을 하는 UI. 드래그하여 이동 가능하도록 구현될 수 있다.
28. ***버튼 UI*** (Button UI): 사용자의 클릭 입력을 받아 특정 기능을 수행하는 UI 요소.
29. ***레벨 순회*** (Level Traversal): 트리 구조에서 같은 깊이(레벨)에 있는 노드들을 순서대로 방문하는 순회 방식. 너비 우선 탐색(BFS)과 유사하다.
30. ***큐*** (Queue): First-In, First-Out (FIFO) 방식으로 데이터를 저장하고 꺼내는 자료구조.
31. ***리스트*** (List): 순서가 있는 데이터의 나열을 표현하는 자료구조. C++의 std::list.
32. ***정적 변수*** (Static Variable): 프로그램 실행 동안 메모리에 유지되는 변수. 함수 내에서 선언되면 해당 함수 내에서만 접근 가능하지만, 함수 호출이 끝나도 소멸되지 않는다.
33. ***얕은 복사*** (Shallow Copy): 객체를 복사할 때 멤버 변수의 값만 복사하는 방식. 포인터 멤버의 경우 포인터 값만 복사되어 원본 객체와 복사본 객체가 같은 메모리 공간을 가리키게 된다.
34. ***깊은 복사*** (Deep Copy): 객체를 복사할 때 멤버 변수의 값과 함께 포인터가 가리키는 메모리 공간의 데이터까지 새로 할당하여 복사하는 방식. 원본 객체와 복사본 객체가 독립적인 메모리 공간을 가진다.
35. ***클론*** (Clone): 오브젝트의 복사본을 생성하는 함수 또는 메서드. 특히 객체 지향에서 다형성을 이용하여 정확한 타입의 복사본을 생성할 때 사용된다.
36. ***복사 생성자*** (Copy Constructor): 같은 타입의 다른 오브젝트를 인자로 받아 새로운 오브젝트를 생성하는 생성자. 오브젝트 복사 시 호출된다.
37. ***이터레이터*** (Iterator): 컨테이너의 요소에 순차적으로 접근하기 위한 객체.
38. ***타겟 UI*** (Target UI): 마우스 클릭이나 다른 이벤트의 대상이 되는 가장 특정적인 UI.
39. ***포커싱*** (Focusing): 현재 사용자 입력(키보드, 마우스 클릭 등)을 직접 받아 처리하는 UI가 지정되는 상태. 여러 UI 중 하나만 포커싱될 수 있다.
40. ***콜백 함수*** (Callback Function): 특정 이벤트가 발생했을 때 시스템이나 다른 코드가 호출하도록 등록해 둔 함수. UI 버튼 클릭 시 호출될 함수 등록 등에 사용된다.
41. ***함수 포인터*** (Function Pointer): 함수의 메모리 주소를 저장하는 포인터. 함수를 변수처럼 다루고 다른 함수에 인자로 전달하거나 저장해 두었다가 나중에 호출할 수 있다.
42. ***파라미터*** (Parameter) / 인자 (Argument): 함수를 호출할 때 함수로 전달되는 값.
43. ***씬*** (Scene): 게임 레벨이나 특정 화면을 구성하는 오브젝트들의 집합. 씬 전환 시 기존 씬의 오브젝트들은 대부분 소멸된다.
44. ***씬 체인지*** (Scene Change): 현재 씬에서 다른 씬으로 전환되는 것.
45. ***다운 캐스팅*** (Downcasting): 부모 클래스 포인터나 참조를 자식 클래스 포인터나 참조로 변환하는 것.