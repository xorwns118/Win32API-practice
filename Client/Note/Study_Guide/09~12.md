Win32 API 및 게임 개발 학습 가이드
===

퀴즈
---

1. 정수형 좌표 대신 실수형 좌표를 사용하는 주된 이유는 무엇이며, 화면 렌더링 시에는 어떤 방식으로 처리되는가? <br/>
2. 게임 개발에서 "벡터"라는 용어가 자료 구조가 아닌 수학적 의미로 사용될 때, 주로 무엇을 나타내기 위해 사용되는가?<br/>
3. 클라이언트 PC의 성능 차이가 게임 오브젝트의 이동 속도에 미치는 문제를 해결하기 위해 도입되는 핵심 개념은 무엇이며, 그 이유는 무엇인가?<br/>
4. 시간 동기화를 위해 timeBeginPeriod() 대신 고성능 카운터를 사용하는 이유는 무엇이며, 고성능 카운터의 주요 특징 두 가지를 설명하시오.<br/>
5. 한 프레임이 걸린 시간 (deltaTime)은 게임 루프에서 어떤 중요한 역할을 수행하며, 어떻게 계산되는가?<br/>
6. 더블 버퍼링의 주된 목적은 무엇이며, 화면 깜빡임 현상을 어떻게 줄여주는가?<br/>
7. 더블 버퍼링을 구현하기 위해 필요한 핵심적인 Win32 API 객체 두 가지는 무엇이며, 각각 어떤 역할을 하는가?<br/>
8. BeginPaint()와 GetDC() 함수의 주요 차이점은 무엇이며, 게임 루프의 상황에 따라 어떤 함수를 선택해야 하는가?<br/>
9. 게임 개발에서 매 프레임마다 화면 전체를 다시 그리는 방식이 이전 프레임의 변경 사항만 업데이트하는 방식보다 유리한 주된 이유는 무엇인가?<br/>
10. AdjustWindowRect() 함수는 어떤 목적으로 사용되며, 함수 호출 시 필요한 주요 정보는 무엇인가?<br/>

퀴즈 정답
---

1. 실수형 좌표를 사용하는 주된 이유는 오브젝트의 미세한 움직임을 더 정확하게 표현하고, 정수 단위 움직임으로 인한 과도한 이동 속도 문제를 해결하기 위함입니다. 화면 렌더링 시에는 실수형 좌표 값이 가장 가까운 정수 픽셀 좌표로 캐스팅되어 실제 화면에 그려집니다.<br/>
2. 수학적 의미의 "벡터"는 게임 개발에서 주로 크기와 방향을 동시에 나타내는 데 사용됩니다. 예를 들어, 오브젝트의 이동 방향과 속도를 하나의 벡터로 표현하여 좌표를 효율적으로 관리할 수 있습니다.<br/>
3. 클라이언트 PC 성능 차이에 따른 이동 속도 문제를 해결하기 위해 시간 동기화 개념이 도입됩니다. 이는 각 PC의 프레임 속도에 관계없이 실제 시간당 오브젝트의 이동 거리를 일정하게 유지하기 위함입니다.<br/>
4. timeBeginPeriod()는 해상도가 낮아 정밀한 시간 측정이 어렵고, 더 정확하고 미세한 단위의 시간 측정을 위해 고성능 카운터 (QueryPerformanceCounter)를 사용합니다. 고성능 카운터의 주요 특징은 높은 해상도로 시간을 측정할 수 있다는 점과, 시스템 부팅 이후 누적된 카운트 값을 제공한다는 점입니다.<br/>
5. 한 프레임이 걸린 시간 (deltaTime)은 시간 동기화의 핵심 요소로, 오브젝트의 움직임이나 애니메이션 속도를 실제 시간에 비례하여 조정하는 데 사용됩니다. 이는 현재 프레임의 고성능 카운터 값에서 이전 프레임의 카운터 값을 빼고, 이를 초당 카운터 빈도수 (Frequency)로 나누어 계산합니다.<br/>
6. 더블 버퍼링의 주된 목적은 화면 깜빡임(flickering) 현상을 줄이고 부드러운 렌더링을 제공하는 것입니다. 이는 백 버퍼라는 보이지 않는 메모리 영역에 먼저 그림을 그린 후, 완성된 이미지를 한 번에 프론트 버퍼(실제 화면)로 복사함으로써 이루어집니다.<br/>
7. 더블 버퍼링 구현에 필요한 핵심 Win32 API 객체는 DC (Device Context)와 Bitmap입니다. 백 버퍼에 그림을 그리기 위한 메모리 DC와, 그림 데이터를 저장할 Bitmap 객체가 필요하며, 이 둘을 연결하여 사용합니다.<br/>
8. BeginPaint() 함수는 WM_PAINT 메시지를 처리할 때 사용되며, 무효화 영역에 대한 DC를 얻고 EndPaint()와 쌍으로 사용되어 무효화 영역 처리를 완료함을 시스템에 알립니다. 반면 GetDC() 함수는 메시지 처리와 관계없이 언제든지 화면 DC를 얻을 수 있지만, 반드시 ReleaseDC()로 해제해야 합니다. 게임 루프에서는 매 프레임 렌더링을 위해 GetDC()를 사용할 수 있습니다.<br/>
9. 매 프레임마다 화면 전체를 다시 그리는 방식은 게임과 같이 역동적인 화면에서 변화를 일관성 있게 처리하고, 복잡한 장면 관리 부담을 줄여줍니다. 이전 프레임의 변경 사항만 추적하고 업데이트하는 것보다 구현이 간단하며, 모든 오브젝트의 상태를 매번 갱신하여 화면에 반영할 수 있습니다.<br/>
10. AdjustWindowRect() 함수는 클라이언트 영역(실제로 그림이 그려지는 영역)이 원하는 크기가 되도록 윈도우 전체 크기를 계산하는 데 사용됩니다. 함수 호출 시 필요한 주요 정보는 원하는 클라이언트 영역의 크기, 윈도우 스타일, 그리고 메뉴 유무입니다.<br/>

에세이 형식 질문
---

1. 시간 동기화가 게임 개발에서 필수적인 이유를 설명하고, 이를 구현하기 위한 구체적인 단계를 제시하시오.<br/>
2. 더블 버퍼링이 현대적인 게임 렌더링 파이프라인에서 중요한 역할을 하는 이유를 기술하고, 싱글 버퍼링 방식의 문제점과 비교하여 설명하시오.<br/>
3. Win32 API 환경에서 효율적인 게임 루프를 설계하기 위한 주요 고려 사항은 무엇이며, 메시지 기반 처리 방식과 폴링 방식의 장단점을 비교 분석하시오.<br/>
4. 게임 오브젝트의 위치, 크기, 움직임을 관리하기 위한 클래스 구조를 설계하고, 캡슐화, 상속, 다형성과 같은 객체 지향 프로그래밍 원리가 어떻게 적용될 수 있는지 설명하시오.<br/>
5. CPU 기반 렌더링과 GPU 기반 렌더링의 주요 차이점을 설명하고, Win32 API를 이용한 CPU 기반 렌더링의 한계점과 이를 극복하기 위한 방안을 논하시오.<br/>

용어 사전
---

1. ***픽셀*** (Pixel): 디지털 이미지를 구성하는 가장 작은 단위의 점. 화면에 표시되는 색상의 기본 요소입니다.<br/>
2. ***좌표*** (Coordinates): 화면 또는 공간 상의 특정 위치를 나타내는 값의 쌍 (일반적으로 x, y).<br/>
3. ***해상도*** (Resolution): 화면에 표시될 수 있는 픽셀의 수. 가로 픽셀 수와 세로 픽셀 수의 곱으로 나타냅니다 (예: 1280x768).<br/>
4. ***렌더링*** (Rendering): 컴퓨터 프로그램을 사용하여 데이터로부터 이미지나 비디오를 생성하는 과정. 게임에서는 게임 상태를 기반으로 화면을 그리는 과정을 의미합니다.<br/>
5. ***FPS*** (Frames Per Second): 1초 동안 화면에 그려지는 프레임의 수. 게임의 부드러움을 나타내는 지표입니다.<br/>
6. ***시간 동기화*** (Time Synchronization): 게임 로직의 업데이트나 렌더링 속도를 실제 시간에 맞춰 일관성을 유지하는 기술. PC 성능 차이로 인한 게임 속도 변화를 방지합니다.<br/>
7. ***델타 타임*** (Delta Time): 이전 프레임과 현재 프레임 사이의 시간 간격. 시간 동기화에 사용되어 움직임이나 속도를 실제 시간에 비례하게 조절합니다.<br/>
8. ***더블 버퍼링*** (Double Buffering): 화면 깜빡임을 줄이기 위해 두 개의 버퍼(프론트 버퍼와 백 버퍼)를 사용하는 렌더링 기술.<br/>
9. ***DC*** (Device Context): 윈도우즈에서 그림을 그리는 데 필요한 정보를 담고 있는 커널 오브젝트. 어떤 장치에 어떻게 그림을 그릴지에 대한 속성을 정의합니다.<br/>
10. ***Bitmap***: 픽셀 데이터의 배열로 이미지를 저장하는 형식 또는 메모리 영역.<br/>
11. ***핸들*** (Handle): 운영체제가 관리하는 객체(윈도우, DC, Bitmap 등)를 식별하기 위해 프로그램에 제공하는 고유한 값.<br/>
12. ***메시지 큐*** (Message Queue): 윈도우즈에서 발생하는 이벤트(키보드 입력, 마우스 클릭 등) 메시지들이 순서대로 저장되는 큐.<br/>
13. ***게임 루프*** (Game Loop): 게임의 핵심적인 흐름을 반복하는 구조. 일반적으로 입력 처리, 게임 로직 업데이트, 렌더링 단계를 포함합니다.<br/>
14. ***폴링*** (Polling): 특정 조건이나 상태를 주기적으로 확인하는 방식. 게임 루프에서 키 입력 상태를 지속적으로 확인하는 데 사용될 수 있습니다.<br/>
15. ***비동기 키 입력*** (Asynchronous Key Input): 현재 시점에서 키의 눌림 상태를 즉시 확인하는 방식. 메시지 기반 입력 처리와 달리 이벤트 발생을 기다리지 않습니다.<br/>