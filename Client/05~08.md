Win32 API 학습 가이드
===

퀴즈
---

1. 더블 버퍼링이 필요한 이유는 무엇인가요? <br/>
2. Win32 API에서 메시지 기반 프로그래밍의 한계는 무엇인가요?<br/>
3. GetMessage 함수와 PeekMessage 함수의 주요 차이점은 무엇인가요?<br/>
4. 싱글톤 패턴의 목적은 무엇인가요?<br/>
5. C++에서 private 생성자를 사용하는 이유는 무엇인가요?<br/>
6. C++에서 static 멤버 함수는 어떤 특징을 가지나요?<br/>
7. C++에서 static 멤버 변수는 어떤 특징을 가지나요?<br/>
8. 매크로 함수의 장점과 단점은 무엇인가요?<br/>
9. 미리 컴파일된 헤더(Precompiled Header)의 목적은 무엇인가요?<br/>
10. 프로그램의 핵심 역할을 담당하는 코어 클래스를 싱글톤으로 관리하는 이유는 무엇인가요?<br/>

퀴즈 정답
---

1. 더블 버퍼링은 화면 깜빡임 현상을 줄이기 위해 필요합니다. 화면에 그리는 과정을 중간에 보여주는 것이 아니라, 완성된 이미지를 한 번에 보여줌으로써 부자연스러운 끊김을 방지합니다. 이를 통해 사용자에게 더 부드러운 시각적 경험을 제공할 수 있습니다.<br/>
2. 메시지 기반 프로그래밍은 특정 이벤트가 발생해야만 프로그램이 반응하도록 설계되어 있어, 메시지가 없는 동안에는 프로그램이 멈춘다는 한계가 있습니다. 이는 지속적인 화면 업데이트나 자체적인 로직 실행이 필요한 게임 개발 등에서 비효율적인 구조가 될 수 있습니다.<br/>
3. GetMessage 함수는 메시지 큐에 메시지가 도착할 때까지 프로그램 실행을 멈추고 대기하지만, PeekMessage 함수는 메시지 유무와 관계없이 즉시 반환됩니다. PeekMessage는 메시지가 있을 경우 메시지 정보를 반환하고, 없을 경우에도 즉시 리턴하여 프로그램이 계속 실행될 수 있도록 합니다.<br/>
4. 싱글톤 패턴의 목적은 특정 클래스의 인스턴스를 오직 하나만 생성되도록 보장하고, 프로그램 내 어디서든 그 유일한 인스턴스에 접근할 수 있도록 하는 것입니다. 이는 프로그램의 핵심 기능을 담당하는 클래스와 같이 단 하나의 객체로 관리해야 하는 경우에 유용합니다.<br/>
5. private 생성자를 사용하는 주된 이유는 외부 클래스에서 해당 클래스의 직접적인 객체 생성을 막기 위함입니다. 이를 통해 클래스 설계자가 객체 생성 방식을 제어하고, 싱글톤 패턴 구현과 같이 특정 방식으로만 객체를 얻도록 강제할 수 있습니다.<br/>
6. static 멤버 함수는 클래스의 객체 없이도 호출될 수 있으며, 객체에 종속되지 않습니다. 따라서 일반 멤버 변수에는 직접 접근할 수 없지만, static 멤버 변수에는 접근이 가능합니다. 주로 유틸리티 함수나 싱글톤 패턴의 인스턴스 접근 메서드 구현에 사용됩니다.<br/>
7. static 멤버 변수는 클래스의 모든 객체가 공유하는 단 하나의 변수이며, 객체가 생성되기 전에도 존재합니다. 데이터 영역에 할당되며, 클래스 스코프 내에서 접근할 수 있습니다. 클래스 선언 외부에서 명시적으로 초기화해야 합니다.<br/>
8. 매크로 함수의 장점은 함수 호출 오버헤드가 없어 성능 향상에 도움이 될 수 있다는 것입니다. 단점으로는 전처리기에 의해 단순 치환되므로 타입 검사를 하지 않고, 부작용 발생 가능성이 있으며, 디버깅이 어려울 수 있다는 점이 있습니다. 또한 연산자 우선순위 문제에 주의해야 합니다.<br/>
9. 미리 컴파일된 헤더의 주된 목적은 컴파일 속도를 향상시키는 것입니다. 자주 사용되고 변경되지 않는 헤더 파일들을 미리 컴파일하여 저장해두고, 프로젝트 빌드 시 이 미리 컴파일된 결과를 재사용함으로써 불필요한 재컴파일 시간을 줄입니다.<br/>
10. 프로그램의 핵심 기능을 담당하는 코어 클래스를 싱글톤으로 관리하는 이유는 프로그램 전체에서 단 하나의 인스턴스만 존재하도록 보장하여 일관된 상태 관리와 접근을 용이하게 하기 위함입니다. 또한 초기화 및 리소스 관리를 중앙 집중화하여 효율성을 높일 수 있습니다.<br/>

에세이 형식 질문
---

1. Win32 API 기반 게임 개발에서 메시지 기반 방식과 PeekMessage를 사용한 게임 루프 방식의 장단점을 비교하고, 후자를 선택하는 주된 이유를 설명하십시오.<br/>
2. 싱글톤 패턴을 적용하는 다양한 시나리오를 제시하고, 코어 클래스를 싱글톤으로 관리하는 것이 게임 아키텍처에 미치는 긍정적 및 부정적 영향을 분석하십시오.<br/>
3. C++에서 static 키워드의 다양한 용도(멤버 변수, 멤버 함수)를 설명하고, 싱글톤 패턴 구현에서 static 멤버가 필수적인 이유를 논하십시오.<br/>
4. 매크로 함수를 사용할 때 발생할 수 있는 잠재적인 문제점들을 구체적인 예시와 함께 설명하고, C++에서 매크로 대신 사용할 수 있는 더 안전한 대안들을 제시하십시오.<br/>
5. 대규모 Win32 API 프로젝트에서 미리 컴파일된 헤더를 사용하는 것이 빌드 시간에 미치는 영향을 분석하고, 효과적인 미리 컴파일된 헤더 관리를 위한 전략을 제안하십시오.<br/>

용어 사전
---

1. ***더블 버퍼링*** (Double Buffering): 화면에 이미지를 그리는 과정에서 발생하는 깜빡임을 줄이기 위해 두 개의 메모리 버퍼를 사용하는 기술. 하나는 화면에 표시하는 데 사용되고, 다른 하나에는 다음 프레임을 미리 그림.<br/>
2. ***메시지 큐*** (Message Queue): 윈도우 시스템에서 발생하는 다양한 이벤트(키보드 입력, 마우스 움직임 등)에 대한 메시지들이 순서대로 저장되는 공간.<br/>
3. ***게임 루프*** (Game Loop): 게임의 핵심 흐름을 담당하는 무한 루프. 사용자 입력 처리, 게임 상태 업데이트, 화면 렌더링 등의 작업을 반복적으로 수행.<br/>
4. ***싱글톤 패턴*** (Singleton Pattern): 특정 클래스의 인스턴스가 오직 하나만 생성되도록 제한하고, 프로그램 내 어디서든 그 유일한 인스턴스에 접근할 수 있도록 하는 디자인 패턴.<br/>
5. ***생성자*** (Constructor): 객체가 생성될 때 자동으로 호출되어 객체의 초기화를 담당하는 특별한 멤버 함수.<br/>
6. ***소멸자*** (Destructor): 객체가 소멸될 때 자동으로 호출되어 객체가 사용했던 자원을 해제하는 특별한 멤버 함수.<br/>
7. ***private 접근 지정자*** (Private Access Specifier): 클래스 멤버에 대한 접근 권한을 클래스 내부로만 제한하는 키워드.<br/>
8. ***static 멤버*** (Static Member): 클래스의 모든 객체가 공유하는 멤버. static 멤버 변수는 데이터 영역에 할당되며, static 멤버 함수는 객체 없이 호출 가능.<br/>
9. ***매크로 함수*** (Macro Function): 전처리기에 의해 코드 내에서 단순 텍스트 치환으로 동작하는 유사 함수 형태의 매크로.<br/>
10. ***미리 컴파일된 헤더*** (Precompiled Header): 자주 사용되고 변경되지 않는 헤더 파일들을 미리 컴파일하여 저장해두고, 프로젝트 빌드 시 재사용함으로써 컴파일 시간을 단축시키는 기술.<br/>