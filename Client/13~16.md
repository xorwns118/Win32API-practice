Win32API 키 및 씬 매니저 스터디 가이드
===

퀴즈
---

1. 키 매니저가 필요한 첫 번째 이유는 무엇이며, 이를 통해 얻을 수 있는 이점은 무엇인가?<br/>
2. 윈도우에서 제공하는 기본적인 키 입력 함수를 직접 사용하는 것과 키 매니저를 사용하는 것의 차이점은 무엇인가?<br/>
3. 키 상태를 나타내는 네 가지 상태(TAP, HOLD, AWAY, NONE)에 대해 간략히 설명하시오.<br/>
4. 키 매니저의 업데이트 과정에서 각 키의 상태를 체크하기 위해 어떤 윈도우 API 함수를 사용하는가? 또한, 실제 가상 키 값과 프로그램 내부에서 정의한 키 값을 어떻게 연결하는가?<br/>
5. 윈도우 포커싱 상태 변화에 따라 키 매니저가 키 상태를 어떻게 처리하는지 설명하시오.<br/>
6. 씬(Scene)의 개념과 씬 매니저(Scene Manager)의 역할에 대해 설명하시오.<br/>
7. 오브젝트(Object)를 그룹별로 관리하는 이유는 무엇이며, 씬 클래스에서 이를 어떻게 구현하는가?<br/>
8. 전방 선언(Forward Declaration)을 사용하는 이유는 무엇이며, 씬 클래스에서 오브젝트를 관리할 때 포인터 타입을 사용하는 이유는 무엇인가?<br/>
9. 씬 클래스의 소멸자에서 가상 함수를 사용하는 이유는 무엇인가?<br/>
10. 순수 가상 함수(Pure Virtual Function)의 개념과 씬 클래스에서 엔터(Enter) 함수를 순수 가상 함수로 선언하는 이유는 무엇인가?<br/>

퀴즈 정답
---

1. 키 매니저가 필요한 첫 번째 이유는 프레임 동기화이다. 이를 통해 한 프레임에서 발생하는 키 입력에 대해 모든 오브젝트가 동일한 상태를 적용받을 수 있도록 보장하여 불일치를 방지할 수 있다.<br/>
2. 윈도우 기본 함수는 단순한 키 눌림 상태만 제공하지만, 키 매니저는 이전 프레임과의 비교를 통해 키가 처음 눌렸는지, 계속 눌려있는지, 또는 놓였는지 등의 구체적인 키 이벤트를 파악하고 관리할 수 있도록 한다.<br/>
3. TAP은 키가 이번 프레임에 막 눌린 상태, HOLD는 키가 이전 프레임부터 계속 눌려있는 상태, AWAY는 키가 이전 프레임까지 눌려있다가 이번 프레임에 막 놓인 상태, NONE은 키가 이전 프레임에도 눌리지 않았고 현재도 눌리지 않은 상태를 의미한다.<br/>
4. GetAsyncKeyStat 함수를 사용하여 각 키의 눌림 상태를 확인한다. 프로그램 내부적으로 정의한 키 값(enum)과 실제 가상 키 값(VK_LEFT 등)을 매칭시키기 위해 배열을 사용하여 연결한다.<br/>
5. 윈도우가 포커싱을 잃으면 키 매니저는 모든 키 상태를 "놓임(AWAY 또는 NONE)" 상태로 처리한다. HOLD 상태의 키는 AWAY 상태로 변경되고, 이후 NONE 상태로 전환되어 포커싱이 돌아올 때까지 키 입력이 발생하지 않도록 한다.<br/>
6. 씬은 게임의 스테이지나 화면 구성을 나타내는 단위로, 여러 오브젝트들을 포함하고 관리한다. 씬 매니저는 이러한 여러 씬들을 생성, 관리하고 현재 활성화된 씬을 제어하여 게임의 흐름을 관리하는 역할을 한다.<br/>
7. 오브젝트를 그룹별로 관리하는 이유는 게임 내의 다양한 종류의 오브젝트(플레이어, 몬스터, UI 등)를 효율적으로 분류하고 관리하기 위해서이다. 씬 클래스에서는 벡터의 배열을 사용하여 각 그룹별로 오브젝트들을 저장하고 관리한다.<br/>
8. 전방 선언은 컴파일 속도를 향상시키고 헤더 파일 간의 불필요한 의존성을 줄이기 위해 사용된다. 씬 클래스에서 오브젝트를 관리할 때 포인터 타입을 사용하는 이유는 다양한 종류의 오브젝트들을 부모 클래스(CObject) 포인터로 통일하여 관리하기 위함이며, 아직 구체적인 타입이 결정되지 않은 오브젝트들을 다루기 위해서이다.<br/>
9. 씬 매니저가 부모 클래스(CScene) 포인터로 파생된 다양한 씬 객체들을 관리할 때, 씬이 소멸될 때 실제 객체의 소멸자가 호출되도록 보장하기 위해서이다. 이를 통해 파생 클래스에서 할당한 리소스들을 안전하게 해제할 수 있다.<br/>
10. 순수 가상 함수는 파생 클래스에서 반드시 재정의해야 하는 함수로, 부모 클래스에서는 구현이 제공되지 않는다. CScene의 엔터 함수를 순수 가상 함수로 선언하는 이유는 각 씬이 시작될 때 수행해야 하는 초기화 작업을 파생 클래스에서 반드시 구현하도록 강제하고, CScene 자체로는 객체를 생성할 수 없도록 하기 위함이다.<br/>

에세이 형식 질문
---

1. 키 매니저를 설계하고 구현하는 과정에서 고려해야 할 디자인 패턴과 원칙에 대해 논하시오. (예: 단일 책임 원칙, 개방-폐쇄 원칙 등)<br/>
2. 다양한 게임 상황을 예로 들어, 키 매니저가 제공하는 구체적인 키 이벤트(TAP, HOLD, AWAY) 활용 방안에 대해 상세히 설명하시오.<br/>
3. 씬 매니저의 역할과 중요성을 강조하고, 씬 기반 구조가 게임 개발의 유지보수성 및 확장성에 미치는 영향에 대해 논하시오.<br/>
4. 오브젝트 그룹 관리 방식을 설계할 때 고려해야 할 사항과, 다양한 그룹 전략(예: 레이어 기반, 타입 기반)의 장단점에 대해 비교 분석하시오.<br/>
5. 상속과 다형성의 개념을 활용하여 씬 및 오브젝트 관리 시스템을 설계하는 이유와 이점에 대해 구체적인 예시를 들어 설명하시오.<br/>

용어 사전
---

1. ***프레임 동기화*** (Frame Synchronization): 게임의 한 프레임 내에서 발생하는 모든 이벤트나 상태 변화를 일관성 있게 처리하여 예측 가능하고 안정적인 게임 플레이를 보장하는 기술.<br/>
2. ***키 매니저*** (Key Manager): 키보드 입력 이벤트를 감지하고 관리하여, 단순한 키 눌림 여부를 넘어 키가 눌렸는지, 떼어졌는지, 계속 눌려있는지 등의 상세한 상태 정보를 제공하는 시스템.<br/>
3. ***비동기 키 입력 함수*** (Asynchronous Key Input Function): 프로그램의 흐름과 독립적으로 키 입력을 감지하는 함수. GetAsyncKeyState와 같은 Win32API 함수가 이에 해당한다.<br/>
4. ***가상 키 값*** (Virtual Key Code): 물리적인 키보드 키를 독립적으로 식별하기 위해 운영체제에서 정의한 상수 값. (예: VK_LEFT, VK_SPACE 등)<br/>
5. ***포커싱*** (Focusing): 특정 윈도우 또는 컨트롤이 사용자 입력을 받을 수 있는 활성화된 상태.<br/>
6. ***씬*** (Scene): 게임 화면의 구성 요소와 상태를 나타내는 논리적인 단위. 보통 게임의 스테이지, 메뉴 화면 등을 하나의 씬으로 관리한다.<br/>
7. ***씬 매니저*** (Scene Manager): 게임 내의 여러 씬들을 생성, 관리, 전환하는 역할을 담당하는 시스템.<br/>
8. ***오브젝트*** (Object): 게임 세계를 구성하는 모든 요소 (캐릭터, 배경, 아이템, UI 등)의 기본 단위.<br/>
9. ***그룹*** (Group): 씬 내의 오브젝트들을 특정 기준에 따라 묶어 관리하기 위한 분류 단위.<br/>
10. ***전방 선언*** (Forward Declaration): 컴파일러에게 특정 식별자의 존재를 미리 알리는 선언. 클래스의 경우, 클래스 이름만 선언하여 헤더 파일 포함으로 인한 컴파일 의존성을 줄일 수 있다.<br/>
11. ***포인터*** (Pointer): 메모리 주소를 저장하는 변수.<br/>
12. ***벡터*** (Vector): 동적으로 크기가 조절 가능한 배열 형태의 자료 구조.<br/>
13. ***상속*** (Inheritance): 객체 지향 프로그래밍의 특징 중 하나로, 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 재사용하고 확장할 수 있도록 하는 메커니즘.<br/>
14. ***다형성*** (Polymorphism): 객체 지향 프로그래밍의 특징 중 하나로, 하나의 인터페이스나 부모 클래스 타입으로 여러 종류의 파생 클래스 객체를 다룰 수 있도록 하는 능력.<br/>
15. ***추상화*** (Abstraction): 복잡한 시스템의 핵심적인 부분만 드러내고 불필요한 세부 사항을 숨겨 단순화하는 과정.<br/>
16. ***소멸자*** (Destructor): 객체가 소멸될 때 자동으로 호출되는 특별한 멤버 함수로, 객체가 사용했던 자원을 해제하는 역할을 한다.<br/>
17. ***가상 함수*** (Virtual Function): 부모 클래스에서 선언되고 파생 클래스에서 재정의(override)될 수 있는 멤버 함수. 런타임 시점에 실제 객체의 타입에 따라 호출될 함수가 결정된다.<br/>
18. ***순수 가상 함수*** (Pure Virtual Function): 구현이 제공되지 않고 파생 클래스에서 반드시 재정의해야 하는 가상 함수. 순수 가상 함수를 하나 이상 포함하는 클래스는 추상 클래스가 되어 객체를 직접 생성할 수 없다.<br/>
19. ***싱글톤*** (Singleton): 프로그램 내에서 해당 클래스의 인스턴스가 단 하나만 생성되도록 보장하는 디자인 패턴. 주로 전역적으로 접근해야 하는 매니저 클래스 등에 사용된다.<br/>
20. ***인라인 함수*** (Inline Function): 컴파일러에게 함수 호출 대신 함수 코드를 호출 지점에 직접 삽입하도록 요청하는 키워드 또는 최적화 기법. 작은 크기의 자주 호출되는 함수에 사용되어 성능 향상을 기대할 수 있다.<br/>
21. ***프로텍티드*** (Protected): 클래스 멤버의 접근 지정자 중 하나로, 해당 클래스와 파생 클래스에서 접근할 수 있도록 허용한다. 외부에서의 직접적인 접근은 불가능하다.<br/>
22. ***폴더*** (Hold): 키가 눌려진 상태를 유지하는 것.<br/>
23. ***태핑*** (Tapping): 키를 짧게 한 번 눌렀다 떼는 행위.<br/>
